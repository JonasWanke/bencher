---
title: "libtest bench"
description: "A step-by-step guide on how to benchmark Rust code with libtest bench"
heading: "How to benchmark Rust code with libtest bench"
sortOrder: 1
---

import Benchmarking from "../../../chunks/rust/en/benchmarking.mdx";
import FizzBuzzRules from "../../../chunks/rust/en/fizz-buzz-rules.mdx";
import MicroVsMacro from "../../../chunks/rust/en/micro-vs-macro.mdx";

<Benchmarking />

## What is Rust?

Rust is an open source programming language that emphasizes speed, memory safety, and productivity.
It was specifically designed to handle the demands of large-scale, concurrent systems.
Rust achieves memory safety without the need for a garbage collector,
which makes it a perfect fit for systems programming.

The language has gained popularity for applications that require complex concurrency
or a high level of security such as operating systems, file systems, game engines, and browser components.
Rust‚Äôs unique combination of performance and safety features makes it an excellent choice
when considering a language for system-level programming and projects where memory-level detail control is required.
Developer productivity is also enhanced by Rust's strong emphasis on error messages and toolchains.

Cargo is the official package manager for the Rust programming language.
It proves developers with a direct method for managing project dependencies and compilation processes.
By automating many tasks, such as building the code, downloading the libraries your project relies on,
and compiling those libraries, Cargo significantly simplifies the processes and enhances the productivity for Rust developers.
Cargo also supports useful features like linting, formatting, building unit tests and benchmarks, using crates from the crates.io registry, and managing multiple native dependencies.


## Write FizzBuzz in Rust

<FizzBuzzRules />

```rust
fn main() {
    for i in 1..=100 {
        match (i % 3, i % 5) {
            (0, 0) => println!("FizzBuzz"),
            (0, _) => println!("Fizz"),
            (_, 0) => println!("Buzz"),
            (_, _) => println!("{i}"),
        }
    }
}
```

### Follow Step-by-Step

In order to follow along with this set-by-step tutorial, you will need to [install Rust](https://rustup.rs/).

With Rust installed, you can then open a terminal window and enter: `cargo init fizz_buzz`

Then navigate into the newly created `fizz_buzz` directory.

```
fizz_buzz
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ main.rs
```

You should see a directory called `src` with file named `main.rs`:

```rust
fn main() {
    println!("Hello, world!");
}
```

Replace its contents with the above FizzBuzz implementation. Then run `cargo run`.
The output should look like:

```
$ cargo run
   Compiling playground v0.0.1 (/playground)
    Finished dev [unoptimized + debuginfo] target(s) in 0.44s
     Running `target/debug/playground`

1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
...
97
98
Fizz
Buzz
```

> üê∞ Boom! You're cracking the coding interview!

A new `Cargo.lock` file should have been generated:

```
fizz_buzz
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ main.rs
```

Before going any further, it is important to discuss the differences between micro-benchmarking and macro-benchmarking.

<MicroVsMacro />

## Benchmarking in Rust

The three popular options for benchmarking in Rust are:
[libtest bench](https://doc.rust-lang.org/rustc/tests/index.html#benchmarks),
[Criterion](https://github.com/bheisler/criterion.rs), and
[Iai](https://github.com/bheisler/iai).

libtest is Rust's built-in unit testing and benchmarking framework.
Though part of the Rust standard library, libtest bench is still considered unstable,
so it is only available on nightly compiler releases.
To work on the stable Rust compiler,
[a separate benchmarking harness](https://github.com/bluss/bencher)
needs to be used.
Neither is being actively developed, though.

The most actively maintained benchmarking harness within the Rust ecosystem is Criterion.
It works on both stable and nightly Rust compiler releases,
and it has become the de facto standard within the Rust community.
Criterion is also much more feature-rich compared to libtest bench.

An experimental alternative to Criterion is Iai, from the same creator as Criterion.
However, it uses instruction counts instead of wall clock time:
CPU instructions, L1 accesses, L2 access and RAM accesses.
This allows for single-shot benchmarking since these metrics should stay nearly identical between runs.

All three are [support by Bencher](/docs/explanation/adapters). So why choose libtest bench?
It may be a good idea if you are trying to limit the external dependencies of your project
and your project is already using the nightly toolchain.
Outside of that, I would suggest using either Criterion or Iai depending on your use case.

### Install Rust nightly

With all that said, we're going to use libtest bench, so let's set our Rust toolchain to nightly.
Create a `rust-toolchain.toml` file in the root of your `fizz_buzz` project, next to `Cargo.toml`.

```toml
[toolchain]
channel = "nightly"
```

Your directory structure should now look like this:

```
fizz_buzz
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ rust-toolchain.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ main.rs
```

Once that is complete, rerun `cargo run`.
It should take minute for the new, nightly toolchain to install
before rerunning and giving you the same output as before.

### Refactor FizzBuzz

In order to test our FizzBuzz application, we need to decouple our logic from program's `main` function.
Benchmark harnesses can't benchmark the `main` function.

Update your code to look like this:

```rust
fn main() {
    play_fizz_buzz();
}

pub fn play_fizz_buzz() {
    for i in 1..=100 {
        println!("{}", fizz_buzz(i));
    }
}

pub fn fizz_buzz(i: i32) -> String {
    match (i % 3, i % 5) {
        (0, 0) => "FizzBuzz".to_string(),
        (0, _) => "Fizz".to_string(),
        (_, 0) => "Buzz".to_string(),
        (_, _) => i.to_string(),
    }
}
```

We have now separated our code out into three different functions:

- `main`: Then main entrypoint into our program that calls `play_fizz_buzz`
- `play_fizz_buzz`: Iterates through the numbers `1` to `100` inclusive calling `fizz_buzz` for each and printing the result
- `fizz_buzz`: Performs the actual `Fizz`, `Buzz`, `FizzBuzz`, or number logic

## Benchmarking FizzBuzz

In order to use the unstable libtest crate we need to enable the `test` feature for our code and import the `test` crate. Add the following to the _very top_ of `main.rs`:

```rust
#![feature(test)]
extern crate test;
```

Now we're ready to add our first benchmark!
Add the following to the _very bottom_ of `main.rs`:

```rust
#[cfg(test)]
mod benchmarks {
    use test::Bencher;

    use super::play_fizz_buzz;

    #[bench]
    fn bench_play_fizz_buzz(b: &mut Bencher) {
        b.iter(|| play_fizz_buzz());
    }
}
```

- Create a module named `benchmarks` and has the
  [compiler configuration](https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg-attribute)
  set to [`test` mode](https://doc.rust-lang.org/book/ch11-03-test-organization.html#the-tests-module-and-cfgtest).
- Import the `Bencher` benchmark runner. (üê∞ Hey, cool name!)
- Import our `play_fizz_buzz` function.
- Create a benchmark named `bench_play_fizz_buzz` that takes in a mutable reference to `Bencher`.
- Set the `#[bench]` attribute to indicate that `bench_play_fizz_buzz` is a benchmark.
- Use the `Bencher` instance to benchmark `play_fizz_buzz` by running it several times.

Now we're ready to benchmark our code, run `cargo bench`:

```
$ cargo bench
    Finished bench [optimized] target(s) in 0.02s
     Running unittests src/main.rs (target/release/deps/fizz_buzz-68f58c96f4025bd4)

running 1 test
test benchmarks::bench_play_fizz_buzz ... bench:       4,879 ns/iter (+/- 170)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out; finished in 0.68s
```

> üê∞ Lettuce turnip the beet! We've got our first benchmark metrics!
