---
title: "libtest bench"
description: "A step-by-step guide on how to benchmark Rust code with libtest bench"
heading: "How to benchmark Rust code with libtest bench"
sortOrder: 1
---

import Benchmarking from "../../../chunks/rust/en/benchmarking.mdx";
import FizzBuzzRules from "../../../chunks/rust/en/fizz-buzz-rules.mdx";
import MicroVsMacro from "../../../chunks/rust/en/micro-vs-macro.mdx";
import FizzBuzzFibonacciRules from "../../../chunks/rust/en/fizz-buzz-fibonacci-rules.mdx";
import FizzBuzzFibonacciOpenRules from "../../../chunks/rust/en/fizz-buzz-fibonacci-open-rules.mdx";

<Benchmarking />

## What is Rust?

Rust is an open source programming language that emphasizes speed, memory safety, and productivity.
It was specifically designed to handle the demands of large-scale, concurrent systems.
Rust achieves memory safety without the need for a garbage collector,
which makes it a perfect fit for systems programming.

The language has gained popularity for applications that require complex concurrency
or a high level of security such as operating systems, file systems, game engines, and browser components.
Rust‚Äôs unique combination of performance and safety features makes it an excellent choice
when considering a language for system-level programming and projects where memory-level detail control is required.
Developer productivity is also enhanced by Rust's strong emphasis on error messages and toolchains.

Cargo is the official package manager for the Rust programming language.
It proves developers with a direct method for managing project dependencies and compilation processes.
By automating many tasks, such as building the code, downloading the libraries your project relies on,
and compiling those libraries, Cargo significantly simplifies the processes and enhances the productivity for Rust developers.
Cargo also supports useful features like linting, formatting, building unit tests and benchmarks, using crates from the crates.io registry, and managing multiple native dependencies.


## Write FizzBuzz in Rust

<FizzBuzzRules />

```rust
fn main() {
    for i in 1..=100 {
        match (i % 3, i % 5) {
            (0, 0) => println!("FizzBuzz"),
            (0, _) => println!("Fizz"),
            (_, 0) => println!("Buzz"),
            (_, _) => println!("{i}"),
        }
    }
}
```

- Create a `main` function
- Iterate from `1` to `100` inclusively.
- For each number, calculate the modulus (remainder after division) for both `3` and `5`.
- Pattern match on the two remainders.
    If the remainder is `0`, then the number is a multiple of the given factor.
- If the remainder is `0` for both `3` and `5` then print `FizzBuzz`.
- If the remainder is `0` for only `3` then print `Fizz`.
- If the remainder is `0` for only `5` then print `Buzz`.
- Otherwise, just print the number.

### Follow Step-by-Step

In order to follow along with this set-by-step tutorial, you will need to [install Rust](https://rustup.rs/).

With Rust installed, you can then open a terminal window and enter: `cargo init game`

Then navigate into the newly created `game` directory.

```
game
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ main.rs
```

You should see a directory called `src` with file named `main.rs`:

```rust
fn main() {
    println!("Hello, world!");
}
```

Replace its contents with the above FizzBuzz implementation. Then run `cargo run`.
The output should look like:

```
$ cargo run
   Compiling playground v0.0.1 (/home/bencher)
    Finished dev [unoptimized + debuginfo] target(s) in 0.44s
     Running `target/debug/game`

1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
...
97
98
Fizz
Buzz
```

> üê∞ Boom! You're cracking the coding interview!

A new `Cargo.lock` file should have been generated:

```
game
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ main.rs
```

Before going any further, it is important to discuss the differences between micro-benchmarking and macro-benchmarking.

<MicroVsMacro />

## Benchmarking in Rust

The three popular options for benchmarking in Rust are:
[libtest bench](https://doc.rust-lang.org/rustc/tests/index.html#benchmarks),
[Criterion](https://github.com/bheisler/criterion.rs), and
[Iai](https://github.com/bheisler/iai).

libtest is Rust's built-in unit testing and benchmarking framework.
Though part of the Rust standard library, libtest bench is still considered unstable,
so it is only available on nightly compiler releases.
To work on the stable Rust compiler,
[a separate benchmarking harness](https://github.com/bluss/bencher)
needs to be used.
Neither is being actively developed, though.

The most actively maintained benchmarking harness within the Rust ecosystem is Criterion.
It works on both stable and nightly Rust compiler releases,
and it has become the de facto standard within the Rust community.
Criterion is also much more feature-rich compared to libtest bench.

An experimental alternative to Criterion is Iai, from the same creator as Criterion.
However, it uses instruction counts instead of wall clock time:
CPU instructions, L1 accesses, L2 access and RAM accesses.
This allows for single-shot benchmarking since these metrics should stay nearly identical between runs.

All three are [support by Bencher](/docs/explanation/adapters). So why choose libtest bench?
It may be a good idea if you are trying to limit the external dependencies of your project
and your project is already using the nightly toolchain.
Outside of that, I would suggest using either Criterion or Iai depending on your use case.

### Install Rust nightly

With all that said, we're going to use libtest bench, so let's set our Rust toolchain to nightly.
Create a `rust-toolchain.toml` file in the root of your `game` project, next to `Cargo.toml`.

```toml
[toolchain]
channel = "nightly"
```

Your directory structure should now look like this:

```
game
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ rust-toolchain.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ main.rs
```

Once that is complete, rerun `cargo run`.
It should take minute for the new, nightly toolchain to install
before rerunning and giving you the same output as before.

### Refactor FizzBuzz

In order to test our FizzBuzz application, we need to decouple our logic from program's `main` function.
Benchmark harnesses can't benchmark the `main` function.

Update your code to look like this:

```rust
fn main() {
    play_game();
}

pub fn play_game() {
    for i in 1..=100 {
        println!("{}", fizz_buzz(i));
    }
}

pub fn fizz_buzz(i: u32) -> String {
    match (i % 3, i % 5) {
        (0, 0) => "FizzBuzz".to_string(),
        (0, _) => "Fizz".to_string(),
        (_, 0) => "Buzz".to_string(),
        (_, _) => i.to_string(),
    }
}
```

We have now separated our code out into three different functions:

- `main`: Then main entrypoint into our program that calls `play_game`.
- `play_game`: Iterates through the numbers `1` to `100` inclusive calling `fizz_buzz` for each and printing the result.
- `fizz_buzz`: Take an unsigned integer as input and perform the actual `Fizz`, `Buzz`, `FizzBuzz`, or number logic returning the result as a string.

## Benchmarking FizzBuzz

In order to use the unstable libtest crate we need to enable the `test` feature for our code and import the `test` crate. Add the following to the _very top_ of `main.rs`:

```rust
#![feature(test)]
extern crate test;
```

Now we're ready to add our first benchmark!
Add the following to the _very bottom_ of `main.rs`:

```rust
#[cfg(test)]
mod benchmarks {
    use test::Bencher;

    use super::play_game;

    #[bench]
    fn bench_play_game(b: &mut Bencher) {
        b.iter(|| play_game());
    }
}
```

- Create a module named `benchmarks` and has the
  [compiler configuration](https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg-attribute)
  set to [`test` mode](https://doc.rust-lang.org/book/ch11-03-test-organization.html#the-tests-module-and-cfgtest).
- Import the `Bencher` benchmark runner. (üê∞ Hey, cool name!)
- Import our `play_game` function.
- Create a benchmark named `bench_play_game` that takes in a mutable reference to `Bencher`.
- Set the `#[bench]` attribute to indicate that `bench_play_game` is a benchmark.
- Use the `Bencher` instance to benchmark `play_game` by running it several times.

Now we're ready to benchmark our code, run `cargo bench`:

```
$ cargo bench
   Compiling playground v0.0.1 (/home/bencher)
    Finished bench [optimized] target(s) in 0.02s
     Running unittests src/main.rs (target/release/deps/game-68f58c96f4025bd4)

running 1 test
test benchmarks::bench_play_game ... bench:       4,879 ns/iter (+/- 170)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out; finished in 0.68s
```

> üê∞ Lettuce turnip the beet! We've got our first benchmark metrics!

Finally, we can rest our weary developer heads...
Just kidding, our users want a new feature!

## Write FizzBuzzFibonacci in Rust

Our Key Performance Indicators (KPIs) are down, so our Product Manager (PM) wants us to add a new feature.
After much brainstorming and many user interviews, it is decided that good ole FizzBuzz isn't enough.
Kids these days want a new game, FizzBuzzFibonacci.

<FizzBuzzFibonacciRules />

```rust
fn is_fibonacci_number(i: u32) -> bool {
    let (mut previous, mut current) = (0, 1);
    while current < i {
        let next = previous + current;
        previous = current;
        current = next;
    }
    current == i
}
```

- Create a function named `is_fibonacci_number` that takes in an unsigned integer and returns a boolean.
- Initialize our Fibonacci sequence starting with `0` and `1` as the `previous` and `current` numbers respectively.
- Iterate while the `current` number is less than the given number `i`.
- Add the `previous` and `current` number to get the `next` number.
- Update the `previous` number to the `current` number.
- Update the `current` number to the `next` number.
- Once `current` is greater than or equal to the given number `i`, we will exit the loop.
- Check to see is the `current` number is equal to the given number `i` and return that result.

Now we will need to update our `fizz_buzz` function:

```rust
pub fn fizz_buzz_fibonacci(i: u32) -> String {
    if is_fibonacci_number(i) {
        "Fibonacci".to_string()
    } else {
        match (i % 3, i % 5) {
            (0, 0) => "FizzBuzz".to_string(),
            (0, _) => "Fizz".to_string(),
            (_, 0) => "Buzz".to_string(),
            (_, _) => i.to_string(),
        }
    }
}
```

- Rename the `fizz_buzz` function to `fizz_buzz_fibonacci` to make it more descriptive.
- Call our `is_fibonacci_number` helper function.
- If the result from `is_fibonacci_number` is `true` then return `Fibonacci`.
- If the result from `is_fibonacci_number` is `false` then perform the same `Fizz`, `Buzz`, `FizzBuzz`, or number logic returning the result.

Because we rename `fizz_buzz` to `fizz_buzz_fibonacci` we also need to update our `play_game` function:

```rust
pub fn play_game() {
    for i in 1..=100 {
        println!("{}", fizz_buzz_fibonacci(i));
    }
}
```

Both our `main` and `bench_play_game` functions can stay exactly the same.

## Benchmarking FizzBuzzFibonacci

Now we can rerun our benchmark:

```
$ cargo bench
   Compiling playground v0.0.1 (/home/bencher)
    Finished bench [optimized] target(s) in 0.00s
     Running unittests src/main.rs (target/release/deps/game-68f58c96f4025bd4)

running 1 test
test benchmarks::bench_play_game ... bench:       5,391 ns/iter (+/- 116)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out; finished in 0.62s
```

Scrolling back through our terminal history,
we can make an eyeball comparison between the performance of our FizzBuzz and FizzBuzzFibonacci games: `4,879 ns` vs `5,391 ns`.
Your numbers will be a little different than mine.
However, the difference between the two games is likely in the 10% range.
That seems good to me! Especially for adding a feature as fancy sounding as _Fibonacci_ to our game.
The kids will love it!

## Expand FizzBuzzFibonacci in Rust

Our game is a hit! The kids do indeed love playing FizzBuzzFibonacci.
So much so that word has come down from the execs that they want a sequel.
But this is the modern world, we need Annual Recurring Revenue (ARR) not one time purchases.
The new vision for our game is that it is open ended, no more living between the bound of `1` and `100` (even if it is inclusive).
No, we're on to new frontiers!

<FizzBuzzFibonacciOpenRules />
