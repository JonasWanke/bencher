---
title: "GitHub Actions"
description: "Utilisez Bencher dans GitHub Actions pour des tests de performance continus sur les pull requests"
heading: "Comment utiliser Bencher dans GitHub Actions"
sortOrder: 3
---

import GitHubActions1 from "../../../chunks/how_to/github-actions.1.mdx";
import GitHubActions2 from "../../../chunks/how_to/github-actions.2.mdx";
import GitHubActions3 from "../../../chunks/how_to/github-actions.3.mdx";
import GitHubActions4 from "../../../chunks/how_to/github-actions.4.mdx";
import GitHubActions5 from "../../../chunks/how_to/github-actions.5.mdx";

<GitHubActions1 />

1. Créez un fichier `workflow` pour GitHub Actions. (ex: `.github/workflows/benchmark.yml`)
2. Exécutez sur les événements `push` vers la branche `main`. Consultez la [documentation `on` de GitHub Actions](https://docs.github.com/fr/actions/using-workflows/workflow-syntax-for-github-actions#on) pour une vue d'ensemble complète. Voir aussi [Pull Requests](#pull-requests) ci-dessous.
3. Créez un `job` pour GitHub Actions. (ex: `benchmark_with_bencher`)
4. Le Projet doit déjà exister. Définissez le drapeau `--project` ou la variable d'environnement `BENCHER_PROJECT` avec le slug ou l'UUID du Projet (ex: `BENCHER_PROJECT: save-walter-white`).
5. Le jeton API doit déjà exister. Ajoutez `BENCHER_API_TOKEN` en tant que secret **Repository**. (ex: `Repo -> Settings -> Secrets and variables -> Actions -> New repository secret`). Définissez le drapeau `--token`ou la variable d'environnement `BENCHER_API_TOKEN` avec le jeton API.  (ex: `BENCHER_API_TOKEN: ${{ secrets.BENCHER_API_TOKEN }}`)
6. Optionnel : réglez le drapeau `--testbed` ou la variable d'environnement `BENCHER_TESTBED` amenant au slug ou à l'UUID de Testbed.  (ex: `BENCHER_TESTBED: ubuntu-latest`) Le Testbed **doit** déjà exister. Si ce n'est pas défini, le Testbed `localhost` sera utilisé.
7. Optionnel : réglez le drapeau `--adapter` ou la variable d'environnement `BENCHER_ADAPTER` avec le nom de l'adaptateur désiré.  (ex: `BENCHER_ADAPTER: json`) Si ce n'est pas défini, l'Adaptateur `magic` sera utilisé. Consultez les [adaptateurs de harnais de benchmark](/docs/fr/explanation/adapters) pour une vue d'ensemble complète.
8. Extraites votre code source. (ex: `uses: actions/checkout@v3`)
9. Installez le CLI de Bencher en utilisant [GitHub Action](https://github.com/marketplace/actions/bencher-cli). (ex: `uses: bencherdev/bencher@main`)
10. [Suivez vos benchmarks](/docs/fr/how-to/track-benchmarks) avec la sous-commande CLI <code><a href="/docs/fr/explanation/bencher-run">bencher run</a></code>:
    1. Optionnel : réglez le drapeau `--branch` ou la variable d'environnement `BENCHER_BRANCH` avec le slug ou l'UUID de la Branche. (ex: `--branch main`). La Branche **doit** déjà exister. Si ce n'est pas défini, la branche `main` sera utilisée.
    2. Paramétrez la commande pour échouer si une Alerte est générée. (ex: `--err`) Pour qu'une Alerte soit générée, un [Seuil](/docs/fr/explanation/thresholds) doit déjà exister.
    3. Exécutez vos benchmarks et générez un Account à partir des résultats. (ex: `"bencher mock"`)

<br/>

## Pull Requests

Pour détecter la régression de performance dans les Pull Requests, vous devrez exécuter vos benchmarks sur les PRs.
Si vous prévoyez uniquement d'avoir des PRs provenant de branches au sein du **même** dépôt, vous pouvez simplement modifier l'exemple ci-dessus pour également exécuter `on` sur les événements `pull_request`.

> ⚠️ Cette solution ne fonctionne que si toutes les PRs proviennent du **même** dépôt!
> Voir [Pull Requests à partir de Forks](#pull-requests-from-forks) ci-dessous.

<GitHubActions2 />

1. Exécutez sur les événements `push` à la branche `main` et sur les événements `pull_request`. Il est important de limiter l'exécution `on` `push` **uniquement** à certaines branches selectionnées (ex: `main`) pour empêcher les pushes vers les branches de PR de s'exécuter deux fois!
2. Au lieu d'utiliser toujours la branche `main`, utilisez les [variables d'environnement par défaut de GitHub Action](https://docs.github.com/fr/actions/learn-github-actions/variables#default-environment-variables) pour :
        1. Utiliser des données de branche actuelles si elles existent déjà. (ex: `--if-branch --if-branch '${{ env.PR_HEAD }}'`)
        2. Créer un clone des données et des seuils de la branche cible de la PR si cela existe déjà. (ex: `--else-if-branch '${{ github.base_ref }}'`)
        3. Sinon, créez un clone des données et des seuils de la branche `main`. (ex: `--else-if-branch main`)
        4. Il existe plusieurs options pour définir la branche du projet. Voir la [sélection de branche](/docs/fr/explanation/branch-selection) pour une vue d'ensemble complète.
3. Paramétrez le jeton d'authentification de l'API GitHub. (ex: `--github-actions "${{ secrets.GITHUB_TOKEN }}"`). Lorsque cette option est définie dans le cadre d'une pull request, alors les résultats seront ajoutés à la pull request sous forme de commentaire. Ceci utilise [la variable d'environnement `GITHUB_TOKEN` des GitHub Actions](https://docs.github.com/fr/actions/security-guides/automatic-token-authentication).
4. Consultez la documentation [bencher run](/docs/fr/explanation/bencher-run) pour une vue d'ensemble complète de toutes les façons de configurer le commentaire de pull request avec les drapeaux `--ci-*`.

## Pull Requests à partir de Forks

Si vous prévoyez d'accepter les pull requests à partir de forks, comme c'est souvent le cas dans les projets open source publics,
alors vous devrez gérer les choses un peu différemment.
Pour des raisons de sécurité, les secrets tels que votre `BENCHER_API_TOKEN` et le `GITHUB_TOKEN` ne sont pas disponibles dans GitHub Actions pour les PRs de fork.
C'est-à-dire que si un contributeur externe ouvre une PR à partir d'un fork, l'exemple ci-dessus ne fonctionnera pas.
Il y a trois options pour les PRs de fork :

<ul>
  <li>[Tester la PR de Fork à partir de la Branche Cible](#benchmark-fork-pr-from-target-branch)</li>
  <li>[Tester la PR de Fork à partir de la Branche Cible avec Réviseurs Nécessaires](#benchmark-fork-pr-from-target-branch-with-required-reviewers)</li>
  <li>[Tester la PR de Fork et Télécharger à partir de la Branche par Défaut](#benchmark-fork-pr-and-upload-from-default-branch)</li>
</ul>

### Tester la PR de Fork à partir de la Branche Cible

<GitHubActions3 />

1. Exécutez sur les événements `push` à la branche `main` et [sur les événements `pull_request_target`](https://docs.github.com/fr/actions/using-workflows/events-that-trigger-workflows#pull_request_target).
2. Créez un `job` qui s'exécute uniquement pour les événements `push` à la branche `main`. À part la condition `if`, ce job est presque identique à l'exemple original ci-dessus.
3. Créez un `job` qui s'exécute uniquement pour les événements `pull_request_target`.
   1. Extraites la branche de pull request.
   2. Transmettez directement tous les secrets. Utilisez `--token "${{ secrets.BENCHER_API_TOKEN }}"` au lieu de la variable d'environnement `BENCHER_API_TOKEN`.
   3. Exécutez et suivez vos benchmarks de pull request avec `bencher run`.

Cette configuration fonctionne parce que `pull_request_target` s'exécute dans le contexte de la branche cible de la pull request,
où les secrets tels que votre `BENCHER_API_TOKEN` et le `GITHUB_TOKEN` sont disponibles.
Par conséquent, ce workflow ne s'exécutera que s'il existe sur la branche _cible_.
Évitez de définir des secrets comme des variables d'environnement, comme `BENCHER_API_TOKEN`.
Au lieu de cela, passez explicitement le jeton API à `bencher run`. (ex: `--token "${{ secrets.BENCHER_API_TOKEN }}"`)
Voir ce [document du GitHub Security Lab](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)
et [cet article de blog](https://nathandavison.com/blog/github-actions-and-the-threat-of-malicious-pull-requests)
sur la prévention des requêtes pwn pour une vue d'ensemble complète.

### Tester la PR de Fork à partir de la Branche Cible avec Réviseurs Nécessaires

<GitHubActions4 />

Cette configuration est exactement la même que [Tester la PR de Fork à partir de la Branche Cible](#benchmark-fork-pr-from-target-branch)
avec l'exigence supplémentaire de l'approbation d'un Réviseur Nécessaire avant chaque exécution de pull request de fork.
Les pull requests du même dépôt ne nécessitent pas d'approbation.
Pour configurer cela, vous devez [créer deux Environnements d'Action GitHub](https://docs.github.com/fr/actions/deployment/targeting-different-environments/using-environments-for-deployment#using-an-environment)
(ex: `Repo -> Settings -> Environments -> New environment`).
L'environnement `internal` ne doit avoir aucune `Règles de protection de déploiement`.
Cependant, l'environnement `external` doit avoir des `Réviseurs nécessaires` définis comme ceux de confiance pour réviser les PRs de fork avant le benchmarking.

### Tester la PR de Fork et Télécharger à partir de la Branche par Défaut

<GitHubActions5 />

1. Créez un fichier de workflow `Exécutez et Cachez les Benchmarks`.
1. Exécutez vos benchmarks sur les événements `pull_request`.
1. Sauvegardez les résultats des benchmarks dans un fichier et téléchargez-les comme un artefact.
1. Téléchargez l'événement `pull_request` comme un artefact.
1. Créez un second fichier de workflow, `Suivez les Benchmarks`.
1. Enchaînez `Suivez les Benchmarks` à `Exécutez et Cachez les Benchmarks` avec [l'événement `workflow_run`](https://docs.github.com/fr/actions/using-workflows/events-that-trigger-workflows#workflow_run).
1. Extrayez les données nécessaires de l'événement `pull_request` en cache.
1. Suivez les résultats de benchmark en cache avec `bencher run`.
1. Créez un troisième fichier de workflow et utilisez l'exemple initial ci-dessus pour exécuter sur les événements `push` à la branche `main`.

Cette configuration fonctionne parce que `workflow_run` s'exécute dans le contexte de la branche par défaut du dépôt,
où les secrets tels que votre `BENCHER_API_TOKEN` et le `GITHUB_TOKEN` sont disponibles.
Par conséquent, ces workflows ne s'exécuteront que s'ils existent sur la branche _par défaut_.
Voir [l'utilisation de données provenant du workflow déclencheur](https://docs.github.com/fr/actions/using-workflows/events-that-trigger-workflows#using-data-from-the-triggering-workflow) pour une vue d'ensemble complète.
Le numéro de pull request, la branche de tête et la branche de base utilisés dans le workflow initial doivent être explicitement transmis car ils ne sont pas disponibles à l'intérieur de `workflow_run`.

Il est également _très_ important d'entourer le nom de la branche PR (head ref) de **simples** apostrophes. (ex : `--if-branch '${{ env.PR_HEAD }}'`) Sans quoi, un attaquant pourrait créer une branche malicieusement nommée qui effectue une injection de commande. Consultez ce [compte-rendu du GitHub Security Lab](https://securitylab.github.com/research/github-actions-untrusted-input/) sur la prévention des requêtes pwn provenant d'entrées non fiables pour une vue d'ensemble complète.

<br/>
<br/>

> 🐰 Félicitations ! Vous avez appris à utiliser Bencher dans GitHub Actions ! 🎉

<br/>

<h2><a href="/docs/fr/explanation/benchmarking">Continuez : Vue d'ensemble du Benchmarking ➡</a></h2>
