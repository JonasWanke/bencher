---
title: "GitHub-Aktionen"
description: "Verwenden Sie Bencher in GitHub-Aktionen für kontinuierliches Benchmarking bei Pull Requests"
heading: "Wie Bencher in GitHub-Aktionen verwendet wird"
sortOrder: 3
---

import GitHubActions1 from "../../../chunks/how_to/github-actions.1.mdx";
import GitHubActions2 from "../../../chunks/how_to/github-actions.2.mdx";
import GitHubActions4 from "../../../chunks/how_to/github-actions.4.mdx";
import GitHubActions5 from "../../../chunks/how_to/github-actions.5.mdx";
import GitHubActions6 from "../../../chunks/how_to/github-actions.6.mdx";

<GitHubActions1 />

1. Erstellen Sie eine GitHub Actions `workflow` Datei. (z.B.: `.github/workflows/benchmark.yml`)
2. Führen Sie `push` Events zum `main` Zweig durch. Siehe [GitHub Actions `on` Dokumentation](https://docs.github.com/de/actions/using-workflows/workflow-syntax-for-github-actions#on) für einen vollständigen Überblick. Siehe auch [Pull Requests](#pull-requests) unten.
3. Erstellen Sie eine GitHub Actions `job`. (z.B.: `benchmark_with_bencher`)
4. Das Projekt muss bereits existieren. Setzen Sie das `--project` Flag oder die `BENCHER_PROJECT` Umgebungsvariable auf den Projektslug oder UUID (z.B.: `BENCHER_PROJECT: save-walter-white`).
5. Das API-Token muss bereits existieren. Fügen Sie `BENCHER_API_TOKEN` als **Repository** Geheimnis hinzu. (z.B.: `Repo -> Einstellungen -> Geheimnisse und Variablen -> Aktionen -> Neues Repository-Geheimnis`) Setzen Sie das `--token` Flag oder die `BENCHER_API_TOKEN` Umgebungsvariable auf das API-Token. (z.B.: `BENCHER_API_TOKEN: ${{ secrets.BENCHER_API_TOKEN }}`)
6. Optional: Setzen Sie das `--testbed` Flag oder die `BENCHER_TESTBED` Umgebungsvariable auf den Testbed Slug oder UUID.  (z.B.: `BENCHER_TESTBED: ubuntu-latest`) Das Testbed **muss** bereits existieren. Wird dies nicht gesetzt, wird das `localhost` Testbed verwendet.
7. Optional: Setzen Sie das `--adapter` Flag oder die `BENCHER_ADAPTER` Umgebungsvariable auf den gewünschten Adapternamen.  (z.B.: `BENCHER_ADAPTER: json`) Wird dies nicht gesetzt, wird der `magic` Adapter verwendet. Siehe [Benchmark Harness Adapter](/docs/de/explanation/adapters) für einen vollständigen Überblick.
8. Checken Sie Ihren Quellcode aus. (z.B.: `uses: actions/checkout@v3`)
9.  Installieren Sie die Bencher CLI mit der [GitHub Action](https://github.com/marketplace/actions/bencher-cli). (z.B.: `uses: bencherdev/bencher@main`)
10. [Verfolgen Sie Ihre Benchmarks](/docs/de/how-to/track-benchmarks) mit dem <code><a href="/docs/de/explanation/bencher-run">bencher run</a></code> CLI-Unterbefehl:
    1.  Optional: Setzen Sie das `--branch` Flag oder die `BENCHER_BRANCH` Umgebungsvariable auf den Branch Slug oder UUID. (z.B.: `--branch main`) Der Branch **muss** bereits existieren. Wird dies nicht gesetzt, wird der `main` Branch verwendet.
    2.  Setzen Sie den Befehl zum Fehlschlagen, wenn ein Alarm generiert wird. (z.B.: `--err`) Damit ein Alarm generiert wird, muss bereits ein [Threshold](/docs/de/explanation/thresholds) existieren.
    3.  Führen Sie Ihre Benchmarks durch und erzeugen Sie einen Bericht aus den Ergebnissen. (z.B.: `"bencher mock"`)

<br/>

## Pull-Anfragen

Um eine Performance-Regression in Pull-Anfragen zu erkennen, müssen Sie Ihre Benchmarks bei den PRs durchführen.
Wenn Sie nur erwarten, dass Sie PRs von Zweigen innerhalb des **gleichen** Repositories haben, können Sie das oben stehende Beispiel einfach ändern, um auch bei `pull_request` Events zu laufen.

> ⚠️ Diese Lösung funktioniert nur, wenn alle PRs aus dem **gleichen** Repository stammen!
> Siehe [Pull-Anfragen von Forks](#pull-anfragen-von-forks) unten.

<GitHubActions2 />

1. Führen Sie `push` Events zum `main` Zweig und auf `pull_request` Events aus. Es ist wichtig, das Laufen bei `push` **nur** auf die ausgewählten Zweige zu beschränken (z.B.: `main`), um zu verhindern, dass Pushes zu PR-Zweigen doppelt ausgeführt werden!
2. Verwenden Sie statt dem `main` Zweig immer [die standardmäßigen Umgebungsvariablen der GitHub-Aktion](https://docs.github.com/de/actions/learn-github-actions/variables#default-environment-variables) um:
        1. Die aktuellen Branch-Daten zu verwenden, wenn sie bereits existieren. (z.B.: `--if-branch '${{ github.head_ref }}'`)
        2. Erstellen Sie einen Klon der PR-Zielbranch-Daten und Schwellenwert, wenn sie bereits existieren. (z.B.: `--else-if-branch '${{ github.base_ref }}'`)
        3. Ansonsten erstellen Sie einen Klon der `main` Branch-Daten und Schwellenwerte. (z.B.: `--else-if-branch main`)
        4. Es gibt mehrere Optionen für die Einstellung des Projektbranches. Siehe [Branch Auswahl](/docs/de/explanation/branch-selection) für einen vollständigen Überblick.
3. Setzen Sie das GitHub API Authentifizierungstoken. (z.B.: `--github-actions '${{ secrets.GITHUB_TOKEN }}'`) Wenn diese Option als Teil einer Pull-Anfrage gesetzt ist, werden die Ergebnisse als Kommentar zur Pull-Anfrage hinzugefügt. Dies verwendet [die GitHub Actions `GITHUB_TOKEN` Umgebungsvariable](https://docs.github.com/de/actions/security-guides/automatic-token-authentication).
4. Siehe die [bencher run](/docs/de/explanation/bencher-run) Dokumentation für einen vollständigen Überblick über alle Möglichkeiten zur Konfiguration des Pull-Anfragen-Kommentars mit den `--ci-*` Flags.

## Pull-Anfragen von Forks

Wenn Sie planen, Pull-Anfragen von Forks anzunehmen, wie es oft der Fall bei öffentlichen Open-Source-Projekten ist,
müssen Sie die Dinge ein wenig anders behandeln.
Aus Sicherheitsgründen stehen Geheimnisse wie Ihr `BENCHER_API_TOKEN` und das `GITHUB_TOKEN` nicht in GitHub-Aktionen für Fork-PRs zur Verfügung.
Das heißt, wenn ein externer Beitragender einen PR von einem Fork eröffnet, wird das obige Beispiel nicht funktionieren.
Es gibt drei Optionen für Fork-PRs:

<ul>
  <li>[Benchmark Fork-PR vom Zielbranch](#benchmark-fork-pr-vom-zielbranch)</li>
  <li>[Benchmark Fork-PR vom Zielbranch mit erforderlichen Prüfern](#benchmark-fork-pr-vom-zielbranch-mit-erforderlichen-prufern)</li>
  <li>[Benchmark Fork-PR und Hochladen vom Standardbranch](#benchmark-fork-pr-und-hochladen-vom-standardbranch)</li>
</ul>

### Benchmark Fork-PR vom Zielbranch

<GitHubActions4 />

1. Lauf `push` Events zur `main` Zweig und [zu `pull_request_target` Events](https://docs.github.com/de/actions/using-workflows/events-that-trigger-workflows#pull_request_target).
2. Erstellen Sie einen `job` der nur für `push` Events zum `main` Zweig läuft. Abgesehen von der `if` Bedingung ist dieser Job fast identisch mit dem ursprünglichen Beispiel oben.
3. Erstellen Sie einen `job` der nur für `pull_request_target` Events läuft.
   1. Checkout des Pull-Anfrage-Zweigs.
   2. Übergeben Sie alle Geheimnisse direkt. Verwenden Sie `--token '${{ secrets.BENCHER_API_TOKEN }}'` anstelle der `BENCHER_API_TOKEN` Umgebungsvariable.
   3. Führen Sie Ihre Pull-Anfrage-Benchmarks durch und verfolgen Sie diese mit `bencher run`.

Diese Einrichtung funktioniert, weil `pull_request_target` im Kontext des Zielzweigs der Pull-Anfrage läuft,
wo Geheimnisse wie Ihr `BENCHER_API_TOKEN` und das `GITHUB_TOKEN` verfügbar sind.
Daher wird dieser Workflow nur dann ausgeführt, wenn er auf dem _Ziel_ Zweig existiert.
Vermeiden Sie das Einstellen von Geheimnissen als Umgebungsvariablen, wie `BENCHER_API_TOKEN`.
Übergeben Sie stattdessen das API-Token explizit an `bencher run`. (z.B.: `--token '${{ secrets.BENCHER_API_TOKEN }}'`)
Siehe diese [GitHub Security Lab Aufschreibung](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)
und [diesen Blogbeitrag](https://nathandavison.com/blog/github-actions-and-the-threat-of-malicious-pull-requests)
zur Vermeidung von pwn-Anfragen für einen vollständigen Überblick.

Es ist auch _sehr_ wichtig, den PR-Branch-Namen (Head Ref) in **einfachen** Anführungszeichen zu umschließen. (z.B. `'${{ github.head_ref }}'`) Andernfalls könnte ein Angreifer einen bösartig benannten Zweig erstellen, der Befehlsinjektionen durchführt. Siehe diesen [GitHub Security Lab Bericht](https://securitylab.github.com/research/github-actions-untrusted-input/) über die Vermeidung von Pwn-Anfragen aus nicht vertrauenswürdigen Eingaben für einen vollständigen Überblick.

### Benchmark Fork-PR vom Zielbranch mit erforderlichen Prüfern

<GitHubActions5 />

Diese Einrichtung ist genau die gleiche wie [Benchmark Fork-PR vom Zielbranch](#benchmark-fork-pr-vom-zielbranch)
mit der zusätzlichen Anforderung der Genehmigung eines erforderlichen Prüfer vor jedem Lauf einer Fork-Pull-Anfrage.
Pull-Anfragen aus demselben Repository benötigen keine Genehmigung.
Um dies einzurichten, müssen Sie [zwei GitHub Action-Umgebungen erstellen](https://docs.github.com/de/actions/deployment/targeting-different-environments/using-environments-for-deployment#using-an-environment)
(z.B.: `Repo -> Einstellungen -> Umgebungen -> Neue Umgebung`).
Die `interne` Umgebung sollte keine `Schutzregeln für die Bereitstellung` haben.
Die `externe` Umgebung sollte jedoch `Erforderliche Prüfer` haben, die denen vertraut sind, die Fork PRs vor dem Benchmarking überprüfen.

### Benchmark Fork PR und Hochladen vom Standard-Zweig

<GitHubActions6 />

1. Erstellen Sie eine `Run and Cache Benchmarks` Workflow-Datei.
1. Führen Sie Ihre Benchmarks bei `pull_request` Events durch.
1. Speichern Sie die Benchmark-Ergebnisse in einer Datei und laden Sie diese als Artefakt hoch.
1. Laden Sie das `pull_request` Event als Artefakt hoch.
1. Erstellen Sie eine zweite Workflow-Datei, `Track Benchmarks`.
1. Verketten Sie `Track Benchmarks` mit `Run and Cache Benchmarks` mit dem [Event `workflow_run`](https://docs.github.com/de/actions/using-workflows/events-that-trigger-workflows#workflow_run).
1. Extrahieren Sie die notwendigen Daten aus dem gecachten `pull_request` Event.
1. Verfolgen Sie die gecachten Benchmark-Ergebnisse mit `bencher run`.
1. Erstellen Sie eine dritte Workflow-Datei und verwenden Sie das ursprüngliche obige Beispiel, um `push` Events zur `main` Zweig auszuführen.

Diese Einrichtung funktioniert, weil `workflow_run` im Kontext des Standardzweigs des Repositorys läuft,
wo Geheimnisse wie Ihr `BENCHER_API_TOKEN` und das `GITHUB_TOKEN` verfügbar sind.
Daher werden diese Workflows nur dann ausgeführt, wenn sie auf dem _Standard_ Branch existieren.
Siehe [Verwendung von Daten aus dem auslösenden Workflow](https://docs.github.com/de/actions/using-workflows/events-that-trigger-workflows#using-data-from-the-triggering-workflow) für einen vollständigen Überblick.
Die Pull-Anfrage-Nummer, der Head-Zweig und der Base-Zweig, die im initialen Workflow verwendet wurden, müssen explizit übergeben werden, da sie innerhalb von `workflow_run` nicht verfügbar sind.

<br/>
<br/>

> 🐰 Herzlichen Glückwunsch! Sie haben gelernt, wie man Bencher in GitHub-Aktionen verwendet! 🎉

<br/>

<h2><a href="/docs/de/explanation/benchmarking">Weitermachen: Überblick über Benchmarking ➡</a></h2>
