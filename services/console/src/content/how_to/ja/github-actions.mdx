---
title: "GitHub Actions"
description: "プルリクエストに対して連続的なベンチマーキングを行うためのBencherをGitHub Actionsで使用する"
heading: "GitHub ActionsでBencherを使用する方法"
sortOrder: 3
---

import GitHubActions1 from "../../../chunks/how_to/github-actions.1.mdx";
import GitHubActions2 from "../../../chunks/how_to/github-actions.2.mdx";
import GitHubActions3 from "../../../chunks/how_to/github-actions.3.mdx";
import GitHubActions4 from "../../../chunks/how_to/github-actions.4.mdx";
import GitHubActions5 from "../../../chunks/how_to/github-actions.5.mdx";

<GitHubActions1 />

1. GitHub Actions `workflow` ファイルを作成します。(例: `.github/workflows/benchmark.yml`)
2. `main` ブランチへの `push` イベントで実行します。全体的な概要については、[GitHub Actions の `on` ドキュメンテーション](https://docs.github.com/ja/actions/using-workflows/workflow-syntax-for-github-actions#on) をご覧ください。また、下記の [Pull Requests](#pull-requests) もご覧ください。
3. GitHub Actions `job` を作成します。(例: `benchmark_with_bencher`)
4. プロジェクトはすでに存在している必要があります。`--project` フラグを設定するか、`BENCHER_PROJECT` 環境変数をプロジェクトのスラッグかUUIDに設定します (例: `BENCHER_PROJECT: save-walter-white`).
5. APIトークンはすでに存在している必要があります。`BENCHER_API_TOKEN` を **リポジトリの** シークレットとして追加します (例: `Repo -> Settings -> Secrets and variables -> Actions -> New repository secret`). `--token` フラグまたは `BENCHER_API_TOKEN` 環境変数にAPIトークンを設定します (例: `BENCHER_API_TOKEN: ${{ secrets.BENCHER_API_TOKEN }}`).
6. 任意: `--testbed` フラグまたは `BENCHER_TESTBED` 環境変数にTestbedのスラッグまたはUUIDを設定します (例: `BENCHER_TESTBED: ubuntu-latest`). Testbedはすでに存在している必要があります。これが設定されていない場合、`localhost` Testbedが使用されます。
7. 任意: `--adapter` フラグまたは `BENCHER_ADAPTER` 環境変数に希望するアダプター名を設定します (例: `BENCHER_ADAPTER: json`). これが設定されていない場合、`magic` アダプターが使用されます。全体の概要については、[ベンチマークハーネスアダプター](/docs/ja/explanation/adapters)をご覧ください。
8. ソースコードをチェックアウトします (例: `uses: actions/checkout@v3`).
9. [GitHub Action](https://github.com/marketplace/actions/bencher-cli) を使用してBencher CLIをインストールします (例: `uses: bencherdev/bencher@main`).
10. <code><a href="/docs/ja/explanation/bencher-run">bencher run</a></code> CLIサブコマンドで、[ベンチマークをトラック](/docs/ja/how-to/track-benchmarks)します:
    1. 任意: `--branch` フラグまたは `BENCHER_BRANCH` 環境変数にBranchのスラッグまたはUUIDを設定します (例: `--branch main`). Branchはすでに存在している必要があります。これが設定されていない場合、`main` Branchが使用されます。
    2. アラートが生成された場合にコマンドが失敗するように設定します (例: `--err`). アラートが生成されるためには、すでに[しきい値](/docs/ja/explanation/thresholds)が存在している必要があります。
    3. ベンチマークを実行し、結果からレポートを生成します (例: `"bencher mock"`).

<br/>

## Pull Requests

プルリクエストでパフォーマンスの後退を検知するためには、PRでベンチマークを実行する必要があります。
もし、**同じ**レポジトリ内のブランチからのPRだけを期待するなら、上記の例を単純に修正して `pull_request` イベントでも実行することができます。

> ⚠️ この解決策は、すべてのPRが **同じ** レポジトリからの場合にのみ機能します！
> 下記の [フォークからのプルリクエスト](#pull-requests-from-forks)をご覧ください。

<GitHubActions2 />

1. `main`ブランチへの `push`イベントと`pull_request`イベントで実行します。`push`を **すべての**選択したブランチ（例: `main`）のみに制限することで、PRブランチへのプッシュが2回実行されるのを防ぎます！
2. 常に`main`ブランチを使用する代わりに、[GitHub Actionのデフォルトの環境変数](https://docs.github.com/ja/actions/learn-github-actions/variables#default-environment-variables) を使用して:
        1. すでに存在する場合は、現在のbranchのデータを使用します。(例: `--if-branch --if-branch '${{ env.PR_HEAD }}'`)
        2. すでに存在する場合は、PRターゲットbranchのデータとしきい値をクローンします。(例: `--else-if-branch '${{ github.base_ref }}'`)
        3. それ以外の場合は、`main` branchのデータとしきい値をクローンします。(例: `--else-if-branch main`)
        4. プロジェクトbranchを設定するためのいくつかのオプションがあります。全体の概要については、[branch selection](/docs/ja/explanation/branch-selection) をご覧ください。
3. GitHub APIの認証トークンを設定します。(例: `--github-actions "${{ secrets.GITHUB_TOKEN }}"`) このオプションがプルリクエストの一部として設定されると、結果はプルリクエストにコメントとして追加されます。これは[GitHub Actionsの `GITHUB_TOKEN` 環境変数](https://docs.github.com/ja/actions/security-guides/automatic-token-authentication)を使用します。
4. `--ci-*` フラグを使用したプルリクエストコメントの設定方法については、[bencher run](/docs/ja/explanation/bencher-run) のドキュメンテーションを全面的にご覧ください。

## Forks からの Pull Requests

公開されているオープンソースプロジェクトの場合と同様に、フォークからのプルリクエストを受け入れる予定の場合、少し異なった方法で処理する必要があります。
セキュリティ上の理由から、`BENCHER_API_TOKEN`や`GITHUB_TOKEN`などのシークレットは、fork PRのGitHub Actionsで利用できません。
つまり、外部のコントリビュータがフォークからPRを開くと、上記の例は機能しません。
フォークPRには以下の3つのオプションが存在します。

<ul>
  <li>[ターゲットブランチからのフォークPRのベンチマーク](#benchmark-fork-pr-from-target-branch)</li>
  <li>[ターゲットブランチからのフォークPRのベンチマーク（必須レビュワー付き）](#benchmark-fork-pr-from-target-branch-with-required-reviewers)</li>
  <li>[デフォルトブランチからのフォークPRとアップロード](#benchmark-fork-pr-and-upload-from-default-branch)</li>
</ul>

### ターゲットブランチからのフォークPRのベンチマーク

<GitHubActions3 />

1. `main` ブランチへの `push` イベントと[ `pull_request_target` イベント](https://docs.github.com/ja/actions/using-workflows/events-that-trigger-workflows#pull_request_target)で実行します。
2. `main` ブランチへの `push` イベントのみで実行される `job` を作成します。`if` 条件を除けば、このジョブはオリジナルの例とほぼ同じです。
3. `pull_request_target` イベントのみで実行される `job` を作成します。
   1. プルリクエストブランチをチェックアウトします。
   2. すべてのシークレットを直接渡します。`BENCHER_API_TOKEN` 環境変数の代わりに `--token "${{ secrets.BENCHER_API_TOKEN }}"` を使用します。
   3. プルリクエストのベンチマークを `bencher run` で実行してトラックします。

このセットアップは `pull_request_target` がプルリクエストのターゲットブランチのコンテキストで実行されるため機能します、
ここではあなたの `BENCHER_API_TOKEN` や `GITHUB_TOKEN` などのシークレットが利用可能です。
したがって、このワークフローは、それが _ターゲット_ ブランチに存在する場合にのみ実行されます。
シークレットを環境変数として設定するのは避けてください、例えば `BENCHER_API_TOKEN` など。
代わりに APIトークンを `bencher run` へ明示的に渡してください (例: `--token "${{ secrets.BENCHER_API_TOKEN }}"`).
完全な概観については、この [GitHubセキュリティラボの書き込み](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/) と
[this blog post](https://nathandavison.com/blog/github-actions-and-the-threat-of-malicious-pull-requests) をご覧ください。

### 必須レビュワー付きのターゲットブランチからのフォークPRのベンチマーク

<GitHubActions4 />

このセットアップは[ターゲットブランチからのフォークPRのベンチマーク](#benchmark-fork-pr-from-target-branch)と全く同じですが、
フォークからの各プルリクエストの実行前に、必須のレビュワーからの承認が必要となる追加の要求事項があります。
同じリポジトリからのプルリクエストには承認が必要ありません。
これをセットアップするためには、[2つのGitHub Action Environmentsを作成](https://docs.github.com/ja/actions/deployment/targeting-different-environments/using-environments-for-deployment#using-an-environment)する必要があります (例: `Repo -> Settings -> Environments -> New environment`).
`internal`環境には`Deployment protection rules`は設定せず、
`external`環境はベンチマーキング前にフォークPRをレビューしたと信頼できる者を`Required reviewers`に設定します。

### デフォルトブランチからのフォークPRとアップロード

<GitHubActions5 />

1. `Run and Cache Benchmarks` ワークフローファイルを作成します。
1. `pull_request` イベントでベンチマークを実行します。
1. ベンチマークの結果をファイルに保存し、それらをアーティファクトとしてアップロードします。
1. `pull_request` イベントをアーティファクトとしてアップロードします。
1. 2つ目のワークフローファイル `Track Benchmarks` を作成します。
1. [ `workflow_run` イベント](https://docs.github.com/ja/actions/using-workflows/events-that-trigger-workflows#workflow_run) を使用して `Track Benchmarks` を `Run and Cache Benchmarks` にチェーンします。
1. キャッシュした `pull_request` イベントから必要なデータを抽出します。
1. キャッシュしたベンチマーク結果を `bencher run` でトラックします。
1. 初期の例を使用して、`main` ブランチへの `push` イベントで3つ目のワークフローファイルを実行します。

このセットアップは `workflow_run` がリポジトリのデフォルトブランチのコンテキストで実行されるため機能します、
ここでは `BENCHER_API_TOKEN` や `GITHUB_TOKEN` などのシークレットが利用可能です。
したがって、これらのワークフローは、それが _デフォルト_ ブランチに存在する場合にのみ実行されます。
初期のワークフローで使用されたプルリクエスト番号、ヘッドブランチ、ベースブランチは、`workflow_run` 内部では利用できませんので、明示的に渡す必要があります。
詳細は [トリガーワークフローからのデータ使用](https://docs.github.com/ja/actions/using-workflows/events-that-trigger-workflows#using-data-from-the-triggering-workflow)をご覧ください。

また、PRブランチ名（ヘッド参照）を**単一の**引用符で囲むことも非常に重要です。（例：`--if-branch '${{ env.PR_HEAD }}'`）そうしないと、攻撃者はコマンドインジェクションを行う悪意のある名前のブランチを作成することができます。この[GitHub Security Labの概要](https://securitylab.github.com/research/github-actions-untrusted-input/)を参照して、信頼できない入力からのpwnリクエストを防ぐ完全な概要をご覧ください。

<br/>
<br/>

> 🐰 おめでとうございます！GitHub ActionsでBencherの使用方法がわかりました！ 🎉

<br/>

<h2><a href="/docs/ja/explanation/benchmarking">次に進む: ベンチマーキングの概要 ➡</a></h2>
