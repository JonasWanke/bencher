---
title: "GitHub Actions"
description: "Используйте Bencher в GitHub Actions для непрерывного бенчмаркинга при работе с pull requests"
heading: "Как использовать Bencher в GitHub Actions"
sortOrder: 3
---

import GitHubActions1 from "../../../chunks/how_to/github-actions.1.mdx";
import GitHubActions2 from "../../../chunks/how_to/github-actions.2.mdx";
import GitHubActions4 from "../../../chunks/how_to/github-actions.4.mdx";
import GitHubActions5 from "../../../chunks/how_to/github-actions.5.mdx";
import GitHubActions6 from "../../../chunks/how_to/github-actions.6.mdx";

<GitHubActions1 />

1. Создайте файл `workflow` для GitHub Actions. (пример: `.github/workflows/benchmark.yml`)
2. Запускайте при событиях `push` в `main` ветку. Подробнее см. в [документации GitHub Actions `on`](https://docs.github.com/ru/actions/using-workflows/workflow-syntax-for-github-actions#on) и ниже в разделе [Pull Requests](#pull-requests).
3. Создайте `job` для GitHub Actions. (пример: `benchmark_with_bencher`)
4. Проект уже должен существовать. Установите флаг `--project` или переменную среды `BENCHER_PROJECT` на символическое имя или UUID проекта (пример: `BENCHER_PROJECT: save-walter-white`).
5. API токен уже должен существовать. Добавьте `BENCHER_API_TOKEN` как секрет **репозитория**. (пример: `Repo -> Settings -> Secrets and variables -> Actions -> New repository secret`) Установите флаг `--token` или переменную среды `BENCHER_API_TOKEN` на API токен. (пример: `BENCHER_API_TOKEN: ${{ secrets.BENCHER_API_TOKEN }}`)
6. Необязательный шаг: установите флаг `--testbed` или переменную среды `BENCHER_TESTBED` на символическое имя или UUID Testbed. (пример: `BENCHER_TESTBED: ubuntu-latest`) Testbed **должен** уже существовать. Если это не задано, то будет использоваться Testbed `localhost`.
7. Необязательный шаг: установите флаг `--adapter` или переменную среды `BENCHER_ADAPTER` на желаемое имя адаптера. (пример: `BENCHER_ADAPTER: json`) Если это не задано, то будет использоваться адаптер `magic`. Подробнее см. [адаптеры для benchmark harness](/docs/ru/explanation/adapters).
8. Произведите клонирование вашего исходниго кода. (пример: `uses: actions/checkout@v3`)
9. Установите Bencher CLI используя [GitHub Action](https://github.com/marketplace/actions/bencher-cli). (пример: `uses: bencherdev/bencher@main`)
10. [Отслеживайте свои бенчмарки](/docs/ru/how-to/track-benchmarks) с помощью подкоманды CLI <code><a href="/docs/ru/explanation/bencher-run">bencher run</a></code>:
    1.  Необязательный шаг: установите флаг `--branch` или переменную среды `BENCHER_BRANCH` на символическое имя или UUID ветки. (пример: `--branch main`) Ветвь **должна** уже существовать. Если это не задано, то используется ветвь `main`.
    2.  Установите команду, чтобы она завершилась с ошибкой, если создано предупреждение. (пример: `--err`) Чтобы предупреждение было создано, требуется уже существующий [порог](/docs/ru/explanation/thresholds).
    3.  Запустите бенчмарки и сгенерируйте отчет из результатов. (пример: `"bencher mock"`)

<br/>

## Pull Requests

Чтобы отследить регрессию производительности в Pull Requests, вам потребуется запустить ваши бенчмарки на PRs.
Если вы ожидаете PRs только из ветвей в рамках **одного и того же** репозитория, вы можете просто модифицировать пример выше, чтобы также запускать его `on` `pull_request` событиях.

> ⚠️ Это решение работает, только если все PRs из **одного и того же** репозитория!
> См. ниже [Pull Requests from Forks](#pull-requests-from-forks).

<GitHubActions2 />

1. Запускайте при событиях `push` в `main` ветку и на `pull_request` событиях. Важно ограничить запуск при событии `push` **только** для выбранных ветвей (например, `main`), чтобы предотвратить двойной запуск при пушах в ветки PR!
2. Вместо всегда использования ветки `main`, используйте [переменные среды по умолчанию GitHub Action](https://docs.github.com/ru/actions/learn-github-actions/variables#default-environment-variables) для:
        1. Использование текущих данных ветки, если они уже существуют. (пример: `--if-branch '${{ github.head_ref }}'`)
        2. Создания клонов данных целевой ветки PR и порогов, если они уже существуют. (пример: `--else-if-branch '${{ github.base_ref }}'`)
        3. В других случаях создания клонов данных ветки `main` и порогов. (пример: `--else-if-branch main`)
        4. Есть несколько вариантов установки ветки проекта. Подробнее см. [выбор ветви](/docs/ru/explanation/branch-selection).
3. Установите токен аутентификации на GitHub API. (пример: `--github-actions '${{ secrets.GITHUB_TOKEN }}'`) При установке этой опции как часть pull request, результаты будут добавлены в pull request как комментарий. Используется [переменная среды `GITHUB_TOKEN` в GitHub Actions](https://docs.github.com/ru/actions/security-guides/automatic-token-authentication).
4. См. документацию [bencher run](/docs/ru/explanation/bencher-run) для подробного обзора всех способов настройки комментария к pull request с помощью флагов `--ci-*`.

## Pull Requests из форков

Если вы планируете принимать pull requests от форков, как это часто бывает в открытых проектах с открытым исходным кодом,
то вам придется немного иначе обрабатывать такие ситуации.
По соображениям безопасности, секреты типа вашего `BENCHER_API_TOKEN` и `GITHUB_TOKEN` недоступны в GitHub Actions для PR из форков.
То есть, если внешний участник открывает PR из форка, пример выше не будет работать.
Есть три варианта для PR из форков:

<ul>
  <li>[Benchmark Fork PR from Target Branch](#benchmark-fork-pr-from-target-branch)</li>
  <li>[Benchmark Fork PR from Target Branch with Required Reviewers](#benchmark-fork-pr-from-target-branch-with-required-reviewers)</li>
  <li>[Benchmark Fork PR and Upload from Default Branch](#benchmark-fork-pr-and-upload-from-default-branch)</li>
</ul>

### Benchmark Fork PR из целевой ветки

<GitHubActions4 />

1. Запускайте на событиях `push` в `main` ветку и [на событиях `pull_request_target`](https://docs.github.com/ru/actions/using-workflows/events-that-trigger-workflows#pull_request_target).
2. Создайте `job` который запускается только для событий `push` в `main` ветку. За исключением условия `if`, этот `job` почти идентичен оригинальному примеру выше.
3. Создайте `job` который запускается только для событий `pull_request_target`.
   1. Произведите клонирование ветки pull request.
   2. Передайте все секреты непосредственно. Используйте `--token '${{ secrets.BENCHER_API_TOKEN }}'` вместо переменной среды `BENCHER_API_TOKEN`.
   3. Запустите бенчмарки вашего pull request и отслеживайте их с `bencher run`.

Эта установка работает, потому что `pull_request_target` выполняется в контексте целевой ветки pull request,
где доступны секреты, такие как ваш `BENCHER_API_TOKEN` и `GITHUB_TOKEN`.
Поэтому, этот workflow будет запущен только если он существует на _целевой_ ветке.
Избегайте установки любых секретов в переменных среды, таких как `BENCHER_API_TOKEN`.
Вместо этого явно передавайте API токен в `bencher run`. (пример: `--token '${{ secrets.BENCHER_API_TOKEN }}'`)
Смотрите [GitHub Security Lab write up](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)
и [эту статью в блоге](https://nathandavison.com/blog/github-actions-and-the-threat-of-malicious-pull-requests)
о предотвращении запросов вредоносного контента для подробного обзора.

Также _очень_ важно заключить имя ветки PR (head ref) в **одинарные** кавычки. (например: `'${{ github.head_ref }}'`). В противном случае злоумышленник может создать ветку с злонамеренным названием, которая производит внедрение команд. Подробное описание можно прочитать в этой [статье Лаборатории безопасности GitHub](https://securitylab.github.com/research/github-actions-untrusted-input/) о предотвращении pwn-запросов от ненадежного ввода.

### Benchmark Fork PR из целевой ветки с обязательными ревьюерами

<GitHubActions5 />

Эта установка точно такая же, как и [Benchmark Fork PR из целевой ветки](#benchmark-fork-pr-from-target-branch)
с дополнительным требованием одобрения от Обязательного Ревьюера перед каждым запуском бенчмарка для pull request из форка.
Pull requests из того же репозитория не требуют одобрения.
Для настройки этого вам нужно [создать два окружения GitHub Action](https://docs.github.com/ru/actions/deployment/targeting-different-environments/using-environments-for-deployment#using-an-environment)
(пример: `Repo -> Settings -> Environments -> New environment`).
Окружение `internal` не должно иметь `Deployment protection rules`.
Однако, окружение `external` должно иметь установленными `Required reviewers` тех, кто доверен для просмотра PR из форка перед бенчмаркингом.

### Benchmark Fork PR и загрузка из ветки по умолчанию

<GitHubActions6 />

1. Создайте файл workflow `Run and Cache Benchmarks`.
1. Запустите ваши бенчмарки на событиях `pull_request`.
1. Сохраните результаты бенчмарков в файл и загрузите их как артефакт.
1. Загрузите событие `pull_request` как артефакт.
1. Создайте второй файл workflow, `Track Benchmarks`.
1. Свяжите `Track Benchmarks` с `Run and Cache Benchmarks` по [событию `workflow_run`](https://docs.github.com/ru/actions/using-workflows/events-that-trigger-workflows#workflow_run).
1. Извлеките необходимые данные из закешированного события `pull_request`.
1. Отследите закешированные результаты бенчмарков с `bencher run`.
1. Создайте третий файл workflow и используйте оригинальный пример выше для запуска на событиях `push` в `main` ветку.

Эта установка работает, потому что `workflow_run` выполняется в контексте ветки по умолчанию репозитория,
где доступны секреты, такие как ваш `BENCHER_API_TOKEN` и `GITHUB_TOKEN`.
Поэтому, эти workflow будут запущены только если они существуют на ветке _по умолчанию_.
Смотрите [использование данных от запускающего workflow](https://docs.github.com/ru/actions/using-workflows/events-that-trigger-workflows#using-data-from-the-triggering-workflow) для подробного обзора.
Номер pull request, ветка шапки и основная ветка, использованные в исходном workflow, должны быть явно переданы, так как они недоступны внутри `workflow_run`.

<br/>
<br/>

> 🐰 Поздравляем! Вы научились использовать Bencher в GitHub Actions! 🎉

<br/>

<h2><a href="/docs/ru/explanation/benchmarking">Продолжите: Обзор бенчмаркинга ➡</a></h2>
