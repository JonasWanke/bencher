---
title: "GitHub Actions"
description: "Usa Bencher en GitHub Actions para el benchmarking continuo en las pull requests"
heading: "C√≥mo usar Bencher en GitHub Actions"
sortOrder: 3
---

import GitHubActions1 from "../../../chunks/how_to/github-actions.1.mdx";
import GitHubActions2 from "../../../chunks/how_to/github-actions.2.mdx";
import GitHubActions3 from "../../../chunks/how_to/github-actions.3.mdx";
import GitHubActions4 from "../../../chunks/how_to/github-actions.4.mdx";

<GitHubActions1 />

1. Crea un `workflow` de GitHub Actions (por ejemplo, `.github/workflows/benchmark.yml`).
2. Especifica los eventos en los que deber√≠a correr el workflow `on`. Consulta la [documentaci√≥n de los eventos `on` en GitHub Actions](https://docs.github.com/es/actions/using-workflows/workflow-syntax-for-github-actions#on) para obtener una visi√≥n completa. Este workflow se ejecuta **solo** en eventos `push` a la rama `main`. Para ejecutarlo [en Pull Requests consulta la secci√≥n a continuaci√≥n](#pull-requests).
3. Crea un `job` de GitHub Actions (por ejemplo, `benchmark_with_bencher`)
4. El proyecto ya debe existir. Configura la bandera `--project` o la variable de entorno `BENCHER_PROJECT` con el slug o UUID del proyecto. (por ejemplo, `BENCHER_PROJECT: save-walter-white`)
5. Agrega `BENCHER_API_TOKEN` a tus secretos del **Repositorio** (por ejemplo, `https://github.com/USERNAME/REPO/settings/secrets/actions`)
6. El token de la API ya debe existir. Establece la bandera `--token` o la variable de entorno `BENCHER_API_TOKEN` con el token de la API. (por ejemplo, `BENCHER_API_TOKEN: ${{ secrets.BENCHER_API_TOKEN }}`)
7. Opcional: Configura la bandera `--adapter` o la variable de ambiente `BENCHER_ADAPTER` con el nombre del adaptador deseado. Si esto no se configura, entonces se usar√° el adaptador `magic`. Consulta los [adaptadores de arneses de benchmark](/docs/es/explanation/adapters) para obtener una visi√≥n completa. (por ejemplo, `BENCHER_ADAPTER: json`)
8. Opcional: Configura la bandera `--testbed` o la variable de entorno `BENCHER_TESTBED` con el slug o UUID del Testbed. El Testbed **debe** existir ya. Si esto no se configura, entonces se usar√° el Testbed `localhost`. (por ejemplo, `BENCHER_TESTBED: ubuntu-latest`)
9. Haz checkout de tu c√≥digo fuente. (por ejemplo, `uses: actions/checkout@v3`)
10. Instala la CLI de Bencher usando la [Acci√≥n de GitHub](https://github.com/marketplace/actions/bencher-cli). (por ejemplo, `uses: bencherdev/bencher@main`)
11. [Rastrea tus benchmarks](/docs/es/how-to/track-benchmarks) con el subcomando de la CLI <code><a href="/docs/es/explanation/bencher-run">bencher run</a></code>:
    1. Hay varias opciones para configurar la rama del proyecto. Consulta la [selecci√≥n de ramas](/docs/es/how-to/branch-selection) para conocer todos los detalles. El comando proporcionado utiliza [las variables de entorno por defecto de GitHub Action](https://docs.github.com/es/actions/learn-github-actions/variables#default-environment-variables) e intenta:
        1. Usar los datos de la rama actual si ya existen. (por ejemplo, `--if-branch "$GITHUB_REF_NAME"`)
        2. Crear un clon de los datos y umbrales de la rama objetivo de la PR si ya existen. (por ejemplo, `--else-if-branch "$GITHUB_BASE_REF"`)
        3. De lo contrario, crea un clon de los datos y umbrales de la rama `main`. (por ejemplo, `--else-if-branch main`)
    2. Configura el comando para fallar si se genera una Alerta. Para que se genere una Alerta, un [Umbral](/docs/es/explanation/thresholds) debe existir ya. (por ejemplo, `--err`)
    3. Configura el token de autenticaci√≥n de la API de GitHub (por ejemplo, `--github-actions ${{ secrets.GITHUB_TOKEN }}`). Cuando esta opci√≥n se configura como parte de una solicitud de extracci√≥n, los resultados se agregar√°n como un comentario a la solicitud de extracci√≥n. El comando proporcionado utiliza [la variable de entorno `GITHUB_TOKEN` de GitHub Actions](https://docs.github.com/es/actions/security-guides/automatic-token-authentication).
    4. Ejecuta tus benchmarks y genera un Informe a partir de los resultados. (por ejemplo, `"bencher mock"`)

<br/>

## Pull Requests

Para detectar las regresiones de rendimiento en las Pull Requests, necesitar√°s ejecutar tus benchmarks en las PRs.
Si solo esperas recibir PRs de ramas dentro del mismo repositorio, entonces puedes simplemente modificar el ejemplo anterior para que tambi√©n se ejecute `on` los eventos de `pull_request`.

<GitHubActions2 />

Es importante limitar la ejecuci√≥n `on` el `push` **solo** a las ramas seleccionadas (por ejemplo, `main`)
para prevenir que los push a las ramas de PR se ejecuten dos veces!
De nuevo, esta soluci√≥n solo funciona si todas las PRs son del **mismo** repositorio.

Si planeas aceptar solicitudes de pull de bifurcaciones, como suele ocurrir en los proyectos de c√≥digo abierto p√∫blico,
entonces necesitar√°s manejar las cosas de manera un poco diferente.
Por razones de seguridad, secretos como tu `BENCHER_API_TOKEN` y el `GITHUB_TOKEN` no est√°n disponibles en GitHub Actions para las PRs de bifurcaciones.
Es decir, si un colaborador externo abre una PR desde una bifurcaci√≥n, el ejemplo anterior no funcionar√°.
Existen dos opciones para las PRs de bifurcaciones:

<ul>
  <li>[Benchmark de la rama PR desde la rama target](#benchmark-pr-branch-from-target-branch)</li>
  <li>[Cache de los resultados del benchmark de la rama PR y subida desde la rama predeterminada](#cache-pr-benchmark-results)</li>
</ul>

### Benchmark de la Rama PR desde la Rama Target

1. Desencadena [el evento `pull_request_target`](https://docs.github.com/es/actions/using-workflows/events-that-trigger-workflows#pull_request_target).
2. Haz checkout de la rama PR.
3. Ejecuta y rastrea tus benchmarks de PR utilizando `bencher run` directamente.

Esto funciona porque `pull_request_target` se ejecuta en el contexto de la rama target de la solicitud de pull,
donde los secretos como tu `BENCHER_API_TOKEN` y el `GITHUB_TOKEN` est√°n disponibles.
Por lo tanto, este workflow solo se ejecutar√° si existe en la rama target.
Evita configurar cualquier secreto como variables de entorno, como `BENCHER_API_TOKEN`.
En su lugar, pasa expl√≠citamente el token de la API a `bencher run` (por ejemplo, `--token ${{ secrets.BENCHER_API_TOKEN }}`).
Consulta este [art√≠culo del GitHub Security Lab](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)
y [este post de blog](https://nathandavison.com/blog/github-actions-and-the-threat-of-malicious-pull-requests)
sobre c√≥mo prevenir solicitudes de pwn para obtener una visi√≥n completa.

<GitHubActions3 />

### Cache de los Resultados del Benchmark PR

1. Ejecuta tus benchmarks de PR en los eventos de `pull_request`.
2. Guarda los resultados de los benchmarks de la PR en un archivo y s√∫belos como un artefacto.
3. Sube el evento de la PR como un artefacto.
4. Encadena ese workflow con [el evento `workflow_run`](https://docs.github.com/es/actions/using-workflows/events-that-trigger-workflows#workflow_run).
5. Extrae los datos necesarios del evento de la PR almacenado en cache.
6. Rastrea los resultados del benchmark de la PR almacenados en cache con `bencher run`.

Esto funciona porque `workflow_run` se ejecuta en el contexto de la rama predeterminada del repositorio,
donde los secretos como tu `BENCHER_API_TOKEN` y el `GITHUB_TOKEN` est√°n disponibles.
Por lo tanto, estos workflows solo se ejecutar√°n si existen en la rama predeterminada.
Consulta [c√≥mo usar los datos del workflow que desencadena](https://docs.github.com/es/actions/using-workflows/events-that-trigger-workflows#using-data-from-the-triggering-workflow) para obtener una visi√≥n completa.
El n√∫mero de la pull request, la rama de origen, y la rama base usados en el workflow inicial deben pasarse expl√≠citamente ya que no est√°n disponibles dentro de `workflow_run`.

<GitHubActions4 />

<br/>
<br/>

> üê∞ ¬°Felicidades! ¬°Has aprendido a usar Bencher en GitHub Actions! üéâ

<br/>

<h2><a href="/docs/es/explanation/benchmarking">Sigue adelante: Visi√≥n general del Benchmarking ‚û°</a></h2>